package com.aminbeheshti.exifviewer

import android.annotation.SuppressLint
import android.content.*
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import android.database.Cursor
import android.net.Uri
import android.os.Bundle
import android.provider.MediaStore
import android.provider.OpenableColumns
import android.util.Log
import android.view.View
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.exifinterface.media.ExifInterface
import com.android.volley.Request
import com.android.volley.RequestQueue
import com.android.volley.toolbox.BasicNetwork
import com.android.volley.toolbox.DiskBasedCache
import com.android.volley.toolbox.HurlStack
import com.android.volley.toolbox.JsonObjectRequest
import com.google.android.material.textfield.TextInputLayout
import java.io.*
import java.lang.String.format
import java.util.*


class MainActivity : AppCompatActivity() {

    private val TAG = "MainActivity"

    companion object {
        private const val PICK_PHOTO_CODE = 655
        private const val READ_EXTERNAL_PHOTOS_CODE = 248
        private const val READ_PHOTO_PERMISSION = android.Manifest.permission.READ_EXTERNAL_STORAGE
    }

    lateinit var imageView: ImageView
    private lateinit var button: Button
    private lateinit var btnCopyAll: Button

    private var imageUri: Uri? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        title = "Exif Viewer"

        // get the package info instance
        val packageInfo: PackageInfo = packageManager.getPackageInfo(packageName, 0)
        // get this app version name programmatically
        val versionName: String = packageInfo.versionName

        imageView = findViewById(R.id.imageView)
        imageView.setImageResource(R.drawable.ic_select_img)
        button = findViewById(R.id.buttonLoadPicture)
        button.setOnClickListener {
            if (isPermissionGranted(this@MainActivity, READ_PHOTO_PERMISSION)) {
                launchIntentForPhotos()
            } else {
                requestPermission(
                        this@MainActivity,
                        READ_PHOTO_PERMISSION,
                        READ_EXTERNAL_PHOTOS_CODE
                )
            }

        }

        val filenameTI: TextInputLayout = findViewById(R.id.filenameTI)
        val imgFormatTI: TextInputLayout = findViewById(R.id.imgFormatTI)
        val imgFileSizeTI: TextInputLayout = findViewById(R.id.imgFileSizeTI)
        val imgWidthTI: TextInputLayout = findViewById(R.id.imgWidthTI)
        val imgHeightTI: TextInputLayout = findViewById(R.id.imgHeightTI)
        val imgDateTI: TextInputLayout = findViewById(R.id.imgDateTI)
        val imgDateDigitizedTI: TextInputLayout = findViewById(R.id.imgDateDigitizedTI)
        val imgLastModifiedDateTI: TextInputLayout = findViewById(R.id.imgLastModifiedDateTI)
        val gpsLatTI: TextInputLayout = findViewById(R.id.GPSLatTI)
        val gpsLongTI: TextInputLayout = findViewById(R.id.GPSLongTI)
        val gpsLocationTI: TextInputLayout = findViewById(R.id.gpsLocationTI)
        val camMakerTI: TextInputLayout = findViewById(R.id.camMakerTI)
        val camModelTI: TextInputLayout = findViewById(R.id.camModelTI)


        val theFileName: EditText = findViewById(R.id.theFileName)
        val imgFormat: EditText = findViewById(R.id.imgFormat)
        val imgFileSize: EditText = findViewById(R.id.imgFileSize)
        val imgWidth: EditText = findViewById(R.id.imgWidth)
        val imgHeight: EditText = findViewById(R.id.imgHeight)
        val imgDate: EditText = findViewById(R.id.imgDate)
        val imgDateDigitized: EditText = findViewById(R.id.imgDateDigitized)
        val imgLastModifiedDate: EditText = findViewById(R.id.imgLastModifiedDate)
        val gpsLat: EditText = findViewById(R.id.GPSLat)
        val gpsLong: EditText = findViewById(R.id.GPSLong)
        val gpsLocation: TextView = findViewById(R.id.gpsLocation)
        val camMaker: EditText = findViewById(R.id.camMaker)
        val camModel: EditText = findViewById(R.id.camModel)

        btnCopyAll = findViewById(R.id.btnCopyAll)
        btnCopyAll.setOnClickListener {
            var allTheData: String?

            if (theFileName.text.toString().isNotEmpty()) {
                allTheData = "File Name: " + theFileName.text.toString() + "\n"
                if (imgFormat.text.isNotEmpty()) {
                    allTheData = allTheData + "Image Format: " + imgFormat.text.toString() + "\n"
                }
                if (imgFileSize.text.isNotEmpty()) {
                    allTheData = allTheData + "Image File Size: " + imgFileSize.text.toString() + "\n"
                }
                if (imgWidth.text.isNotEmpty()) {
                    allTheData = allTheData + "Image Width: " + imgWidth.text.toString() + "\n"
                }
                if (imgHeight.text.isNotEmpty()) {
                    allTheData = allTheData + "Image Height: " + imgHeight.text.toString() + "\n"
                }
                if (imgDate.text.isNotEmpty()) {
                    allTheData = allTheData + "Original Date: " + imgDate.text.toString() + "\n"
                }
                if (imgDateDigitized.text.isNotEmpty()) {
                    allTheData = allTheData + "Digitized Date: " + imgDateDigitized.text.toString() + "\n"
                }
                if (imgLastModifiedDate.text.isNotEmpty()) {
                    allTheData = allTheData + "Last Modified Date: " + imgLastModifiedDate.text.toString() + "\n"
                }
                if (gpsLat.text.isNotEmpty()) {
                    allTheData = allTheData + "GPS Latitude: " + gpsLat.text.toString() + "\n"
                }
                if (gpsLong.text.isNotEmpty()) {
                    allTheData = allTheData + "GPS Longitude: " + gpsLong.text.toString() + "\n"
                }
                if (gpsLocation.text.isNotEmpty()) {
                    allTheData = allTheData + "Readable Address: " + gpsLocation.text.toString() + "\n"
                }
                if (camMaker.text.isNotEmpty()) {
                    allTheData = allTheData + "Camera Maker: " + camMaker.text.toString() + "\n"
                }
                if (camModel.text.isNotEmpty()) {
                    allTheData = allTheData + "Camera Model: " + camModel.text.toString() + "\n"
                }

                allTheData = "$allTheData\nGenerated by Exif Viewer\nversion: $versionName\nwww.AminBeheshti.com"
                copy2Clipboard(allTheData)
                Toast.makeText(this, "Copied to clipboard", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this, "No Data to Copy!", Toast.LENGTH_SHORT).show()
            }
        }


        filenameTI.setEndIconOnClickListener {
            val theLabel = "File Name: "
            validateText(theLabel, theFileName.text.toString())
        }

        imgFormatTI.setEndIconOnClickListener {
            val theLabel = "Image Format: "
            validateText(theLabel, imgFormat.text.toString())
        }

        imgFileSizeTI.setEndIconOnClickListener {
            val theLabel = "Image File Size: "
            validateText(theLabel, imgFileSize.text.toString())
        }

        imgWidthTI.setEndIconOnClickListener {
            val theLabel = "Image Width: "
            validateText(theLabel, imgWidth.text.toString())
        }

        imgHeightTI.setEndIconOnClickListener {
            val theLabel = "Image Height: "
            validateText(theLabel, imgHeight.text.toString())
        }

        imgDateTI.setEndIconOnClickListener {
            val theLabel = "Original Date: "
            validateText(theLabel, imgDate.text.toString())
        }

        imgDateDigitizedTI.setEndIconOnClickListener {
            val theLabel = "Digitized Date: "
            validateText(theLabel, imgDateDigitized.text.toString())
        }

        imgLastModifiedDateTI.setEndIconOnClickListener {
            val theLabel = "Last Modified Date: "
            validateText(theLabel, imgLastModifiedDate.text.toString())
        }

        gpsLatTI.setEndIconOnClickListener {
            val theLabel = "GPS Latitude: "
            validateText(theLabel, gpsLat.text.toString())
        }

        gpsLongTI.setEndIconOnClickListener {
            val theLabel = "GPS Longitude: "
            validateText(theLabel, gpsLong.text.toString())
        }

        gpsLocationTI.setEndIconOnClickListener {
            val theLabel = ""
            validateText(theLabel, gpsLocation.text.toString())
        }

        camMakerTI.setEndIconOnClickListener {
            val theLabel = "Camera Maker: "
            validateText(theLabel, camMaker.text.toString())
        }

        camModelTI.setEndIconOnClickListener {
            val theLabel = "Camera Model: "
            validateText(theLabel, camModel.text.toString())
        }

    }

    override fun onRequestPermissionsResult(
            requestCode: Int,
            permissions: Array<out String>,
            grantResults: IntArray
    ) {
        if (requestCode == READ_EXTERNAL_PHOTOS_CODE) {
            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                launchIntentForPhotos()
            } else {
                Toast.makeText(
                        this,
                        "In order to pick an image from your gallery, you need to provide access to your phone",
                        Toast.LENGTH_LONG
                ).show()
            }
        }

        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
    }

    @SuppressLint("SetTextI18n")
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == RESULT_OK && requestCode == PICK_PHOTO_CODE) {
            imageUri = data?.data

            val filenameTI: TextInputLayout = findViewById(R.id.filenameTI)
            val imgFormatTI: TextInputLayout = findViewById(R.id.imgFormatTI)
            val imgFileSizeTI: TextInputLayout = findViewById(R.id.imgFileSizeTI)

            val imageFilename: EditText = findViewById(R.id.theFileName)
            val imageFormat: EditText = findViewById(R.id.imgFormat)
            val imageFileSize: EditText = findViewById(R.id.imgFileSize)
            imageFileSize.text = null
            imageFormat.text = null
            imageFilename.text = null
            val imgFormat = imageUri?.let { contentResolver.getType(it) }
            imageFormat.setText(imgFormat)
            imgFormatTI.setEndIconDrawable(R.drawable.ic_content_copy)

            val cursorSec: Cursor? = imageUri?.let { contentResolver.query(it, null, null, null, null) }

            if (cursorSec == null) {
                var theFilePath = imageUri?.path
            } else {
                val nameIndex = cursorSec.getColumnIndex(OpenableColumns.DISPLAY_NAME)
                val sizeIndex = cursorSec.getColumnIndex(OpenableColumns.SIZE)
                cursorSec.moveToFirst()
                val pictureFileName = nameIndex.let { cursorSec.getString(it) }
                val pictureSize = sizeIndex.let { cursorSec.getLong(it).toString() }
                cursorSec.close()

                imageFilename.setText(pictureFileName)
                filenameTI.setEndIconDrawable(R.drawable.ic_content_copy)

                val sizeInMb = pictureSize.toLong() / (1024.0 * 1024)
                val sizeInMbStr = "%.2f".format(sizeInMb)
                imageFileSize.setText("$sizeInMbStr MB")
                imgFileSizeTI.setEndIconDrawable(R.drawable.ic_content_copy)
                Log.d(TAG, "Size=${sizeInMbStr}MB")
            }

            imageView.setImageResource(0)
            imageView.setImageURI(imageUri)

            showExif(imageUri)
        }
    }

    @SuppressLint("SetTextI18n")
    private fun showExif(imageUri: Uri?) {
        val latitude: Float
        val longitude: Float

        val inputStream = imageUri?.let { contentResolver.openInputStream(it) }
        val exifInterface = inputStream?.let { ExifInterface(it) }
        val imgWidthExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_IMAGE_WIDTH)
        val imgHeightExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_IMAGE_LENGTH)
        val imgDateExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_DATETIME_ORIGINAL)
        val imgDateDigitizedExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_DATETIME_DIGITIZED)
        val imgLastModifiedDateExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_DATETIME)
        val cameraMakerExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_MAKE)
        val cameraModelExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_MODEL)
        val latGPSExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_GPS_LATITUDE)
        val longGPSExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_GPS_LONGITUDE)
        val latRefExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_GPS_LATITUDE_REF)
        val longRefExif: String? = exifInterface?.getAttribute(ExifInterface.TAG_GPS_LONGITUDE_REF)

        val imageWidth: EditText = findViewById(R.id.imgWidth)
        val imageHeight: EditText = findViewById(R.id.imgHeight)
        val imageDate: EditText = findViewById(R.id.imgDate)
        val imageDateDigitized: EditText = findViewById(R.id.imgDateDigitized)
        val imageLastModifiedDate: EditText = findViewById(R.id.imgLastModifiedDate)
        val cameraMaker: EditText = findViewById(R.id.camMaker)
        val cameraModel: EditText = findViewById(R.id.camModel)
        val latGPS: EditText = findViewById(R.id.GPSLat)
        val longGPS: EditText = findViewById(R.id.GPSLong)
        val readableAddress: TextView = findViewById(R.id.gpsLocation)

        imageWidth.text = null
        imageHeight.text = null
        imageDate.text = null
        cameraMaker.text = null
        cameraModel.text = null
        latGPS.text = null
        longGPS.text = null
        readableAddress.text = null
        imageDateDigitized.text = null
        imageLastModifiedDate.text = null

        // ---------------------------------------------------------------------------------------
        val imgWidthTI: TextInputLayout = findViewById(R.id.imgWidthTI)
        val imgHeightTI: TextInputLayout = findViewById(R.id.imgHeightTI)
        val imgDateTI: TextInputLayout = findViewById(R.id.imgDateTI)
        val imgDateDigitizedTI: TextInputLayout = findViewById(R.id.imgDateDigitizedTI)
        val imgLastModifiedDateTI: TextInputLayout = findViewById(R.id.imgLastModifiedDateTI)
        val gpsLatTI: TextInputLayout = findViewById(R.id.GPSLatTI)
        val gpsLongTI: TextInputLayout = findViewById(R.id.GPSLongTI)
        val camMakerTI: TextInputLayout = findViewById(R.id.camMakerTI)
        val camModelTI: TextInputLayout = findViewById(R.id.camModelTI)

        if (imgWidthExif != null) {
            if (imgWidthExif.isNotEmpty()) {
                imageWidth.setText("$imgWidthExif pixels")
                imgWidthTI.setEndIconDrawable(R.drawable.ic_content_copy)
            }
        }
        if (imgHeightExif != null) {
            imageHeight.setText("$imgHeightExif pixels")
            imgHeightTI.setEndIconDrawable(R.drawable.ic_content_copy)
        }

        if (imgDateExif != null) {
            imageDate.setText(imgDateExif)
            imgDateTI.setEndIconDrawable(R.drawable.ic_content_copy)
        }
        if (imgDateDigitizedExif != null) {
            imageDateDigitized.setText(imgDateDigitizedExif)
            imgDateDigitizedTI.setEndIconDrawable(R.drawable.ic_content_copy)
        }
        if (imgLastModifiedDateExif != null) {
            imageLastModifiedDate.setText(imgLastModifiedDateExif)
            imgLastModifiedDateTI.setEndIconDrawable(R.drawable.ic_content_copy)
        }

        if (cameraMakerExif != null) {
            cameraMaker.setText(cameraMakerExif)
            camMakerTI.setEndIconDrawable(R.drawable.ic_content_copy)
        }
        if (cameraModelExif != null) {
            cameraModel.setText(cameraModelExif)
            camModelTI.setEndIconDrawable(R.drawable.ic_content_copy)
        }

        if ((latGPSExif != null)
                && (latRefExif != null)
                && (longGPSExif != null)
                && (longRefExif != null)) {

            latitude = if (latRefExif == "N") {
                convertToDegree(latGPSExif)
            } else {
                0 - convertToDegree(latGPSExif)
            }

            longitude = if (longRefExif == "E") {
                convertToDegree(longGPSExif)
            } else {
                0 - convertToDegree(longGPSExif)
            }

            latGPS.setText("$latitude")
            longGPS.setText("$longitude")
            gpsLatTI.setEndIconDrawable(R.drawable.ic_content_copy)
            gpsLongTI.setEndIconDrawable(R.drawable.ic_content_copy)

        }

    }

    private fun launchIntentForPhotos() {
        val gallery = Intent(Intent.ACTION_GET_CONTENT, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
        gallery.type = "image/*"
        startActivityForResult(Intent.createChooser(gallery, "Choose an image"), PICK_PHOTO_CODE)
    }

    private fun validateText(theLabel: String, theText: String) {
        val theCompleteText: String = theLabel + theText
        if (theText.isNotEmpty()) {
            copy2Clipboard(theCompleteText)
            Toast.makeText(this, "Copied to Clipboard", Toast.LENGTH_SHORT).show()
        } else Toast.makeText(this, "No Text to Copy!", Toast.LENGTH_SHORT).show()
    }

    private fun copy2Clipboard(text: CharSequence) {
        val clipboard = getSystemService(CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText("copy text", text)
        clipboard.setPrimaryClip(clip)
    }

    fun openLocationOnMap(view: View) {
        val lat: EditText = findViewById(R.id.GPSLat)
        val long: EditText = findViewById(R.id.GPSLong)
        val gpsLat: String = lat.text.toString()
        val gpsLong: String = long.text.toString()

        if (gpsLat.isNotEmpty() && gpsLong.isNotEmpty()) {
            val url = "https://www.google.com/maps?q=$gpsLat,$gpsLong"
            val intent = Intent(Intent.ACTION_VIEW)
            intent.data = Uri.parse(url)
            startActivity(intent)
        } else Toast.makeText(
                this,
                "The coordinate fields are empty or something went wrong!",
                Toast.LENGTH_SHORT
        ).show()
    }

    @SuppressLint("SetTextI18n")
    fun convertToReadableAddress(v: View) {

        val lat: EditText = findViewById(R.id.GPSLat)
        val long: EditText = findViewById(R.id.GPSLong)

        if (lat.text.isNotEmpty() && long.text.isNotEmpty()) {
            val gpsLat: String = (lat.text.toString())
            val gpsLong: String = (long.text.toString())

            if (gpsLat.isNotEmpty() && gpsLong.isNotEmpty()) {
                conToAddressAPI(gpsLat.toDouble(), gpsLong.toDouble())
            }
        } else Toast.makeText(this, "No data to convert!", Toast.LENGTH_SHORT).show()
    }

    private fun conToAddressAPI(lat: Double, long: Double) {
        val readableAddress: TextView = findViewById(R.id.gpsLocation)
        val gpsLocationTI: TextInputLayout = findViewById(R.id.gpsLocationTI)
        var address: String? = null
        var theContinent: String?
        var theCountryCode: String?
        var thePrincipalSubdivision: String?
        var theCity: String?
        var theLocality: String?
        var thePostalCode: String?

        // Instantiate the cache
        val cache = DiskBasedCache(cacheDir, 1024 * 1024) // 1MB cap

        // Set up the network to use HttpURLConnection as the HTTP client.
        val network = BasicNetwork(HurlStack())

        // Instantiate the RequestQueue with the cache and network. Start the queue.
        val requestQueue = RequestQueue(cache, network).apply {
            start()
        }
        val url = "https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=$lat&longitude=$long&localityLanguage=en"

        val jsonObjectRequest = JsonObjectRequest(Request.Method.GET, url, null, { response ->

            theContinent = format(response.getString("continent"))
            theCountryCode = format(response.getString("countryName"))
            thePrincipalSubdivision = format(response.getString("principalSubdivision"))
            theCity = format(response.getString("city"))
            theLocality = format(response.getString("locality"))
            thePostalCode = format(response.getString("postcode"))

            if (thePostalCode != null) {
                if (thePostalCode!!.isNotEmpty()) {
                    address = "$thePostalCode"
                }
            }
            if (theLocality != null) {
                if (theLocality!!.isNotEmpty()) {
                    address = if (address != null) {
                        "$address, $theLocality"
                    } else {
                        "$theLocality"
                    }
                }
            }
            if (theCity != null) {
                if (theCity!!.isNotEmpty()) {
                    address = if (address != null) {
                        "$address, $theCity"
                    } else {
                        "$theCity"
                    }
                }
            }
            if (thePrincipalSubdivision != null) {
                if (thePrincipalSubdivision!!.isNotEmpty()) {
                    address = if (address != null) {
                        "$address, $thePrincipalSubdivision"
                    } else {
                        "$thePrincipalSubdivision"
                    }
                }
            }
            if (theCountryCode != null) {
                if (theCountryCode!!.isNotEmpty()) {
                    address = if (address != null) {
                        "$address, $theCountryCode"
                    } else {
                        "$theCountryCode"
                    }
                }
            }
            if (theContinent != null) {
                if (theContinent!!.isNotEmpty()) {
                    address = if (address != null) {
                        "$address, $theContinent"
                    } else {
                        "$theContinent"
                    }
                }
            }

            readableAddress.text = address
            gpsLocationTI.setEndIconDrawable(R.drawable.ic_content_copy)

        }, { _ ->
            Toast.makeText(this, "Response Error catch", Toast.LENGTH_LONG).show()
        }

        )
        // Access the RequestQueue through your singleton class.
        // Add the request to the RequestQueue.
        requestQueue.add(jsonObjectRequest)
    }

    private fun convertToDegree(stringDMS: String): Float {
        val result: Float?
        val dMS = stringDMS.split((",").toRegex(), 3).toTypedArray()
        val stringD = dMS[0].split(("/").toRegex(), 2).toTypedArray()
        val d0: Double = stringD[0].toDouble()
        val d1: Double = stringD[1].toDouble()
        val floatD = d0 / d1
        val stringM = dMS[1].split(("/").toRegex(), 2).toTypedArray()
        val m0: Double = stringM[0].toDouble()
        val m1: Double = stringM[1].toDouble()
        val floatM = m0 / m1
        val stringS = dMS[2].split(("/").toRegex(), 2).toTypedArray()
        val s0: Double = stringS[0].toDouble()
        val s1: Double = stringS[1].toDouble()
        val floatS = s0 / s1
        result = (floatD + floatM / 60 + floatS / 3600).toFloat()
        return result
    }

}
